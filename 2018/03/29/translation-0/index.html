<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="web英语读物[个人翻译] - 00"/>













  <link rel="alternate" href="/default" title="否极.泰来">




  <link rel="shortcut icon" type="image/x-icon" href="/bitbug_favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://BlackBirch.github.io/2018/03/29/translation-0/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> web英语读物[个人翻译] - 00 - 否极.泰来 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">否极.泰来</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">否极.泰来</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          web英语读物[个人翻译] - 00
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-29
        </span>
        
          <div class="post-category">
            
              <a href="/categories/translation/">translation</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Styling-Empty-Cells-With-Generated-Content-And-CSS-Grid-Layout"><span class="toc-text">Styling Empty Cells With Generated Content And CSS Grid Layout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过生成内容和css的grid布局来设计空的单元格"><span class="toc-text">通过生成内容和css的grid布局来设计空的单元格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-common-Grid"><span class="toc-text">A common Grid</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-Redundant-Elements-As-A-Styling-Hook"><span class="toc-text">Using Redundant Elements As A Styling Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用冗余元素作为样式钩子"><span class="toc-text">使用冗余元素作为样式钩子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-Generated-Content-As-A-Styling-Hook"><span class="toc-text">Using Generated Content As A Styling Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用生成content作为样式钩子"><span class="toc-text">使用生成content作为样式钩子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LIMITATIONS-OF-THE-GENERATED-CONTENT-APPROACH"><span class="toc-text">LIMITATIONS OF THE GENERATED CONTENT APPROACH</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成内容方法的限制"><span class="toc-text">生成内容方法的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fancy-Headings"><span class="toc-text">Fancy Headings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#花销的标题"><span class="toc-text">花销的标题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Adding-Backgrounds-And-Borders-To-Areas-Of-Your-Design"><span class="toc-text">Adding Backgrounds And Borders To Areas Of Your Design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONTROLLING-THE-STACK-WITH-z-index"><span class="toc-text">CONTROLLING THE STACK WITH z-index</span></a></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>这是我的第一篇英语读物翻译，目的是为了学英语+学技术的，翻译水平是小白级别，请大家轻轻看。</p>
<h2 id="Styling-Empty-Cells-With-Generated-Content-And-CSS-Grid-Layout"><a href="#Styling-Empty-Cells-With-Generated-Content-And-CSS-Grid-Layout" class="headerlink" title="Styling Empty Cells With Generated Content And CSS Grid Layout"></a><a href="https://www.smashingmagazine.com/2018/02/generated-content-grid-layout/?utm_source=CSS-Weekly&amp;utm_campaign=Issue-304&amp;utm_medium=email#why-can-t-we-style-empty-areas-already" target="_blank" rel="noopener">Styling Empty Cells With Generated Content And CSS Grid Layout</a></h2><h2 id="通过生成内容和css的grid布局来设计空的单元格"><a href="#通过生成内容和css的grid布局来设计空的单元格" class="headerlink" title="通过生成内容和css的grid布局来设计空的单元格"></a>通过生成内容和css的grid布局来设计空的单元格</h2><h3 id="A-common-Grid"><a href="#A-common-Grid" class="headerlink" title="A common Grid"></a>A common Grid</h3><p>Layout gotcha is when a newcomer to the layout method wonders how to style a grid cell which doesn’t contain any content. In the current Level 1 specification, this isn’t possible since there is no way to target an empty Grid Cell or Grid Area and apply styling.This means that to apply styling, you need to insert an element.</p>
<p>布局陷阱是当一个新手在考虑布局时，想知道如何设计一个不含任何内容的grid cell。在当前第一规范， 这是不可能的，因为没有办法针对一个空的grid cell或是网格区域并应用样式。这意味着要应用样式，你需要添加一个element。</p>
<p>In this article, I am going to take a look at how to use CSS Generated Content to achieve styling of empty cells without adding redundant empty elements and show some use cases where this technique makes sense.</p>
<p>在这篇文章，我会告诉你如何使用CSS 生成content来实现一个不需要添加多余的空element来设计空的单元格并展示一些用例来证明这是有意义的。</p>
<p>Why Can’t We Style Empty Areas Already? The opening paragraph of the Grid Specification says,</p>
<pre><code>“This CSS module defines a two-dimensional grid-based layout system, optimized for user interface design. In the grid layout model, the children of a grid container can be positioned into arbitrary slots in a predefined flexible or fixed-size layout grid.”
</code></pre><p>为什么我们不能写一个空的区域？网格规范的开头部分说，</p>
<pre><code>“这个CSS模块定义了一个基于二维网格的布局系统，优化了用户界面设计。 在网格布局末班中，一个网格容器的子元素可以放置在预定的灵活或固定大小布局网格中任意位置。”
</code></pre><p>The key phrase here is “children of a grid container.” The specification defines the creation of a grid on the parent element, which child items can be positioned into.<br>It doesn’t define any styling of that grid, not even going as far as to implement something like the column-rule property we have in Multi-column Layout. We style the child items, and not the grid itself, which leaves us needing to have an element of some sort to apply that style to.</p>
<p>这里的关键词是“网格容器的子元素。”该规范定义了在父元素上创建网格，可以将子元素定位到。它没有定义该网格的任何样式，甚至不去实现想我们在多行样式中所拥有的列规则属性这样的东西。<br>我们设计子元素，并没有网格本身，这让我们需要有个element来应用该样式。</p>
<h4 id="Using-Redundant-Elements-As-A-Styling-Hook"><a href="#Using-Redundant-Elements-As-A-Styling-Hook" class="headerlink" title="Using Redundant Elements As A Styling Hook"></a>Using Redundant Elements As A Styling Hook</h4><h4 id="使用冗余元素作为样式钩子"><a href="#使用冗余元素作为样式钩子" class="headerlink" title="使用冗余元素作为样式钩子"></a>使用冗余元素作为样式钩子</h4><p>One way to insert something to style is to insert a redundant element into the document, for example, a span or a div. Developers tend to dislike this idea, despite the fact that they have been adding additional redundant “row wrappers” for years in order to achieve grid layouts using floats. Perhaps that obviously empty element is more distasteful than the somewhat hidden redundancy of the wrapper element!</p>
<p>添加一些样式的一种方法是在document中添加一些冗余的元素，例如一个span或是一个div。开发者倾向于不喜欢这个方法，尽管他们多年来为了实现浮动的网格布局而一直添加冗余的“行包装器”。可能明显的空元素比包装器元素的隐藏冗余更令人反感！</p>
<p>Completely empty elements become grid items and can have backgrounds and borders added just like an element that contains content, as this example demonstrates.</p>
<p>完全的空元素成为网格项，并且可以有背景和边框，就像是一个包含内容的元素，如这个例子演示的那样:</p>
<p>Eric Meyer, in his A List Apart article Faux Grid Tracks, advocates for using the b element as your redundant element of choice, as it confers no semantic meaning, is short and also fairly obvious in the markup as a hook.</p>
<p>Eric Meyer,在他的一个列表除了文章“Faux Grid Tracks”，介绍了一个使用b元素作为你冗余元素的选择，因为它没有语义意义，是简短的而且在标记中很明显是个钩子。</p>
<p>Inserting an additional few div or b elements is unlikely to be the greatest crime against good markup you have ever committed, so I wouldn’t lose any sleep over choosing that approach if needed.<br>Web development very often involves picking the least suboptimal approach to getting the job done until a better solution is devised. I do prefer however to keep my styling in one place if possible, safely in the stylesheet. If nothing else, it makes it easier to reuse styles, not needing to worry about the additional required markup.<br>It is for this reason, I tend to look to generated content, something I’m very familiar with from the work I’ve done formatting books with CSS, where you spend most of your time working with this feature.</p>
<p>添加额外的几个div或者b元素不太可能是你犯过的最严重的错误，所以如果需要的话，我不会因为选择这种方法而失眠。网站开发常常涉及到在设计出更好的解决方案之前，选择最不优先的方法来完成工作。不过，如果可以的话，我更愿意在样式表中安全地保留我的样式。如果没有其它，它使重用样式变得更容易，不需要担心额外的需要标记。正是因为这个原因，我倾向于寻找生成的content，这是我从我的工作中非常熟悉的，我已经用CSS完成了格式化书籍，在这里你花费了大量时间来处理这个特性。</p>
<h4 id="Using-Generated-Content-As-A-Styling-Hook"><a href="#Using-Generated-Content-As-A-Styling-Hook" class="headerlink" title="Using Generated Content As A Styling Hook"></a>Using Generated Content As A Styling Hook</h4><h4 id="使用生成content作为样式钩子"><a href="#使用生成content作为样式钩子" class="headerlink" title="使用生成content作为样式钩子"></a>使用生成content作为样式钩子</h4><p>CSS Generated Content uses the ::before and ::after CSS pseudo-classes along with the content property to insert some kind of content into the document. The idea of inserting content might lead you to think that this is for inserting text, and while this is possible, for our purposes we are interested in inserting an empty element as a direct child of our Grid Container. With an element inserted we can style it.</p>
<p>CCS生成content使用::before和::after CSS伪类在内容属性后添加一些content在document里。这个插入content的想法可能会导致您认为是插入文本，虽然这是可能的，但为了我们的目的，我们有兴趣插入一个空的元素最为一个直接子元素在网格容器。插入一个我们可以样式化的元素。</p>
<p>In the below example I have a containing element, which will become my Grid Container, with another element nested inside.<br>This single direct child will become a Grid Item. I’ve defined a three column, three-row grid on the container and then positioned the single item using Grid Lines, so it sits in the middle Grid Cell.</p>
<p>在下面的例子里,我有一个包含元素，它将成为我的网格容器，可以嵌套另一个元素。这个直接的子元素会成为一个网格项。我定义了三行、三列的网格在容器里，然后使用网格线定位单个项，因此它位于中间网格单元中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"grid"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="selector-class">.grid</span> &gt; * &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(137,153,175);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>image1</p>
<p>If we take a look at this example, using the Firefox Grid Inspector to overlay the Grid Lines, we can see how the other empty cells of the grid exist, however, to add a background or border to them we would need to add additional child elements. Which is exactly what Generated Content enables.</p>
<p>如果我们看一下这个例子，使用Firefox网络检查器覆盖网格线，我们可以看到网格中的其他空单元    是如何存在的，但是要添加一个背景或边框，我们需要添加额外的子元素。这正是生成的content支持的内容。</p>
<p>In my CSS I add an empty string, ::before and ::after my Grid Container. These will immediately become Grid Items and stretch to fill their container. I then add the styling I need for the boxes, in this case adding a background color, and position them as I would any regular Grid Item.</p>
<p>在我的CSS中，我添加空的字符串，::before和::after 在我的网格容器。这将立即成为网格项并延伸到他们的容器。然后添加我需要的样式，在这个例子中添加一个背景色，并将它们定义为任何规则网格项。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="built_in">rgb</span>(214,232,182);</span><br><span class="line">	<span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">	<span class="attribute">grid-row</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.grid</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="built_in">rgb</span>(214,232,182);</span><br><span class="line">	<span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">	<span class="attribute">grid-row</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>image2</p>
<p>In the document we still only have one child element, the redundant styling elements are contained within the CSS, which seems perfectly reasonable as they are only there for styling purposes.</p>
<p>在这个document中我们仅仅使用了一个子元素，这个冗余的样式元素包含在CSS中，这看起来非常合理，因为它们只是用于样式化的目的。</p>
<h4 id="LIMITATIONS-OF-THE-GENERATED-CONTENT-APPROACH"><a href="#LIMITATIONS-OF-THE-GENERATED-CONTENT-APPROACH" class="headerlink" title="LIMITATIONS OF THE GENERATED CONTENT APPROACH"></a>LIMITATIONS OF THE GENERATED CONTENT APPROACH</h4><h4 id="生成内容方法的限制"><a href="#生成内容方法的限制" class="headerlink" title="生成内容方法的限制"></a>生成内容方法的限制</h4><p>The obvious issue with this approach will become apparent if you decide you would like to also style the top right and bottom left Grid Cells. You can only apply one piece of generated content to the top and one to the bottom of the container, multiple ::before and ::after pseudo elements are not allowed. The method isn’t going to work if you want to create yourself a CSS Grid chequerboard! If you find that you do need to do a lot of empty cell styling then for the foreseeable future, the “Filler B’s” approach explained above is likely to be your best bet.</p>
<p>这个方法的问题就是当你想将右上和左下的网格项添加样式时会变得明显。你只能将一个生成的内容应用到容器的顶部和底部，多个::before和::after伪类元素是不允许的。如果你想建你的CSS网格棋盘，这种办法是不允许的！ 如果你需要更多的空cell在可预见的未来，“filler B’s”可能是你更好的选择。</p>
<p>The generated content method could also confuse a future developer working on your project. As we are targeting the container, if you reuse that class elsewhere it will bring along the generated content, this is useful if that is what you want. In the next example, we have added decorative lines either side of a heading, it would be reasonable that every instance of an h1 would have those lines. It would, however, be very confusing if you were not aware this was going to happen!<br>A comment line above the container rules will help here. I tend to work these days in a pattern library, which really does help these components neatly in one place, making it more obvious what happens when a class is applied to an element.</p>
<p>这个生成内容的方法也会让将来的开发人员感到困恼。当我们针对容器时，如果你在其他地方重用这个类，它会带来生成内容，如果你想要的话，这是有用的。在下个例子里，我们会在标题的两侧添加装饰性的线条，这样的话，每个h1都有这条线这是合理的。然而，如果你不知道将会发生，那将令人困惑的！写一个注释在容器规则上面会对此有帮助。我现在倾向于在一个模式库中工作，这确实帮助这些组件整洁地在一个地方，使它更明显的发生当一个类被应用到一个元素。</p>
<h4 id="Fancy-Headings"><a href="#Fancy-Headings" class="headerlink" title="Fancy Headings"></a>Fancy Headings</h4><h4 id="花销的标题"><a href="#花销的标题" class="headerlink" title="花销的标题"></a>花销的标题</h4><p>One of my favorite generated content tricks is to style headings. In the past, I had to push back on heading styles that would require additional wrappers and absolute positioning tracks to achieve. When content comes from a CMS, it is often impossible to add those redundant wrappers.</p>
<p>With Grid and generated content, we can add a line either side of our heading without adding any additional markup. The line will grow and shrink according to available space and will fall back elegantly to a plain centered header when Grid is not available in browsers.</p>
<p>我最喜欢的内容技巧之一是装饰标题。在过去，我不得不将标题样式推到后面，这需要额外的包装和绝对定位轨迹来实现。当内容来自CMS时，通常不可能添加那些冗余的包装器。<br>使用网格和生成的内容，我们可以在标题的任何一方添加一行，而不添加任何附加标记。该行将根据可用空间增长和缩小，当浏览器中不存在网格时，该行将优雅地返回到一个简单居中的标题。</p>
<p>Our markup is a simple h1.<br>我们的标记就是一个简单的h1。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>In the rules for the h1 I create a three column grid. The value of grid-template-columns gives a track of 1fr then one of auto and a final track of 1fr. The two 1fr tracks will share the available space left over after the heading has taken the space it needs to be sat inside the auto sized track.<br>在H1的规则中，我创建了一个三列网格。grid-template-columns的1fr位置，一个auto位置和最后位置为1fr。两个1fr将占用可使用的空间，而现在的auto位置被标题占用。</p>
<p>I added the text-align property with a value of center in order than my heading is entered in browsers without grid.<br>我添加了 text-align 属性使我的标题不需要用grid而居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">	<span class="attribute">display</span>: grid;</span><br><span class="line">	<span class="attribute">grid-template-colums</span>: <span class="number">1</span>fr auto <span class="number">1</span>fr;</span><br><span class="line">	<span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We now add our generated content, to add a line before and after the heading text. I wrap these rules in a Feature Query, so we don’t get any weird generated content in browsers without grid layout.</p>
<p>我们现在添加一个生成内容，添加一列 :before 和 :after 都是标题的内容。我将这些规则封装在一个特性查询中，因此在没有网格布局的浏览器中我们不会产生任何奇怪的生成内容。</p>
<p>The line itself is a border on the generated item.<br>该行本身是生成项的边界。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">supports</span> (display: grid) &#123;</span><br><span class="line">    <span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-tag">h1</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">        <span class="attribute">align-self</span>: center;</span><br><span class="line">        <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That’s all you need to do! You could use the same technique to add any styling, or even an icon on both sides of an element, above or below the element. By placing your item into a separate track you know there is no chance that the item could end up overlapping your heading text, which tended to be the problem when trying to do this kind of thing with absolute positioning. You also have the benefit of the precise ways items can be aligned against each other in grid.<br>这就是你所需要做的！您可以使用相同的技术在元素的上方或下方添加元素的任何样式，甚至图标。通过把你的项放在一个单独的轨道上，你知道没有机会结束这个项目重叠你的标题文本，这往往是问题，当试图做这种事情的绝对定位。您还可以从网格中相互对齐的精确方式中获益。</p>
<p>This is a nice example of an enhancement possible using grid layout which you could take advantage of even if you are not ready to head right into a major redesign using grid yet. It falls back very nicely to a straightforward heading, people with supporting browsers get the extra touch, and everyone gets the content. A similar approach was taken by Eric Meyer, using generated content to add easily styleable and positionable quotes to a blockquote element.<br>这是一个很好的例子，可以使用网格布局来增强，即使你还没有准备好使用网格来进行重大的重新设计。它很容易回到一个简单的标题，支持浏览器的人获得额外的触摸，每个人都得到内容。类似的方法被Eric Meyer用生成的内容添加容易styleable和定位的行情blockquote元素。</p>
<p>With these small features, I often don’t start out thinking that I’m going to use Grid Layout. It is as I start to figure out how to implement my design I realize it is the layout method to choose. It’s for this reason that I encourage people not to think of Grid as being for page layout over components if you do so you might miss plenty of opportunities where it can help.</p>
<p>有了这些小特性，我通常不会开始考虑使用网格布局。正是当我开始考虑如何实现我的设计时，我意识到这是布局方法的选择。正是出于这个原因，我鼓励人们不要把网格看作是页面布局的组件，如果这样做的话，你可能会错过很多可以帮助它的机会。</p>
<h3 id="Adding-Backgrounds-And-Borders-To-Areas-Of-Your-Design"><a href="#Adding-Backgrounds-And-Borders-To-Areas-Of-Your-Design" class="headerlink" title="Adding Backgrounds And Borders To Areas Of Your Design"></a>Adding Backgrounds And Borders To Areas Of Your Design</h3><p>将背景和边框添加到设计区域中</p>
<p>We can also use generated content to stack up items; the fact is, more than one item can occupy a particular grid cell. This can include those items inserted with generated content.<br>我们还可以使用生成的内容来堆叠项；事实上，多个项目可以占用特定的网格单元。这可以包括插入生成内容的条目。</p>
<p>In the next example, I have a design with two sections of content and a full-width item. Behind the content is a background which also runs underneath the full-width item.<br>在下一个示例中，我有一个包含两部分内容和一个完整宽度项的设计。后面的内容是一个背景，也在完全宽度项下运行。</p>
<p>The markup has a container with the sections and full-width element as direct children, and I’m using line-based placement to place my items onto the grid.<br>标记有一个容器，其中的区段和等宽元素作为直接子元素，我使用基于行的布局将我的项放置在网格上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"grid"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"section1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"full-width"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">“placeholder.jpg”</span> <span class="attr">alt</span>=<span class="string">“Placeholder”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"section2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">20px</span> <span class="number">4</span>fr <span class="number">20px</span> <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: auto <span class="number">300px</span> auto;</span><br><span class="line">    <span class="attribute">grid-row-gap</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="selector-class">.section1</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="selector-class">.section2</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="selector-class">.full-width</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">1</span> / -<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(214,232,182,.5);</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This gives me the layout with the full-width image and two sections of content placed; however, if I add the background to the sections, it will stop above the row-gap between section and the full-width image.<br>这使我的布局与全宽度图像和两个部分的内容放置，但是，如果我添加背景的部分，它会停止在行之间的差距部分和全宽度图像。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(214,232,182,.3);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="built_in">rgb</span>(214,232,182);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we removed the grid-row-gap and used padding to make the space, it still wouldn’t enable the effect of the background running underneath the full-width panel.<br>如果我们删除了 gird-row-gap 并使用padding来创建空间，它仍然无法将背景运行在全宽度的面板下。</p>
<p>This is where we can use generated content. I add generated content ::before the grid container and give it a background color. If I do nothing else, this will position the content in the first cell of the grid.</p>
<p>这是我们可以使用生成内容的地方。我添加生成的内容:before 在网格容器并给它一个背景色。如果我不做其他事情，这将把内容放在网格的第一个单元格中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(214,232,182,.3);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="built_in">rgb</span>(214,232,182);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I can then position the content using line-based positioning to stretch over the area that should show the background color.<br>然后我可以使用基于线的定位来定位内容，以显示应该显示背景颜色的区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(214,232,182,.3);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="built_in">rgb</span>(214,232,182);</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">2</span> / <span class="number">5</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CONTROLLING-THE-STACK-WITH-z-index"><a href="#CONTROLLING-THE-STACK-WITH-z-index" class="headerlink" title="CONTROLLING THE STACK WITH z-index"></a>CONTROLLING THE STACK WITH z-index</h3><p>用z-index控制堆栈</p>
<p>In the example above, the generated content is inserted with ::before. This means that the other elements come after it, it is at the bottom of the stack and so will display behind the rest of the content which is where I want it. You can also use z-index to control the stack. Try changing the ::before selector to ::after. The generated content background now sits on top of everything, as you can see from the way the border runs over the image. This is because it has now become the last thing in the grid container, it is painted last and so appears “on top.”<br>在上面的例子里，这个生成的内容是添加在::before。这意味着其他element将在它后面，它位于堆栈的底部，这就是我想要的，将显示在其余内容后面。可以使用z-index来控制轨道。尝试将::before选择器替换成::after。这个生成的内容背景现在站在所有的前面，就如你想看到的，边框运营在图片周围。这是因为它将要成为最后一个东西在grid容器里，它最后生成却站在最前面。</p>
<p>To change this, you need to give this element a lower z-index property than everything else. If nothing else has a z-index value, the simplest thing to do is to give your generated content a z-index of -1. This will cause it to be the first thing in the stack, as the item with the lowest z-index.<br>要改变这一点，你需要给这个元素比其他一切下z-index属性。如果没有一个z-index值，最简单的办法就是把你的内容生成属性- 1。这将导致堆栈中的第一个东西，作为项的最低z-index。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(214,232,182,.3);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="built_in">rgb</span>(214,232,182);</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">2</span> / <span class="number">5</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Adding backgrounds in this way doesn’t need to be limited to dropping a background completely behind your content. Being able to pop blocks of color behind part of your design could create some interesting effects.<br>以这种方式添加背景不需要仅限于在内容后面完全丢弃背景。能够在设计的后面弹出颜色块可以产生一些有趣的效果。</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://BlackBirch.github.io">black birch</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://BlackBirch.github.io/2018/03/29/translation-0/">http://BlackBirch.github.io/2018/03/29/translation-0/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/05/31/18-5-31/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">mpvue踩坑记</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2018/03/08/react-native/">
        <span class="next-text nav-default">react-native 总结</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:linjiahua2@163.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/BlackBirch" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">black birch</span>
  </span>
  <div>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  本站总访问量 <span id="busuanzi_value_site_pv"></span> 次&nbsp&nbsp&nbsp
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
  </div>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
